import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import {
  Keypair,
  PublicKey,
  SystemProgram,
  SYSVAR_RENT_PUBKEY,
} from "@solana/web3.js";
import {
  TOKEN_PROGRAM_ID,
  createMint,
  createAccount,
  mintTo,
  getAccount,
} from "@solana/spl-token";
import { assert, expect } from "chai";

// Type will be generated by anchor build
// import { BasiliskEscrow } from "../target/types/basilisk_escrow";

describe("basilisk-escrow", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.BasiliskEscrow as Program<any>;

  // ── Test accounts ─────────────────────────────────────────────────────
  const admin = Keypair.generate();
  const arbitrator = Keypair.generate();
  const requester = Keypair.generate();
  const agent = Keypair.generate();
  const unauthorizedUser = Keypair.generate();

  let mint: PublicKey;
  let requesterToken: PublicKey;
  let agentToken: PublicKey;
  let adminToken: PublicKey;

  const JOB_ID = "test-job-001";
  const JOB_AMOUNT = 10_000_000; // 10 tokens (6 decimals)
  const JOB_DESCRIPTION = "Build governance dashboard";
  const DEADLINE_DAYS = 7;

  // ── PDA derivation helpers ────────────────────────────────────────────
  function findConfigPDA(): [PublicKey, number] {
    return PublicKey.findProgramAddressSync(
      [Buffer.from("config")],
      program.programId
    );
  }

  function findJobPDA(jobId: string): [PublicKey, number] {
    return PublicKey.findProgramAddressSync(
      [Buffer.from("job"), Buffer.from(jobId)],
      program.programId
    );
  }

  function findEscrowAuthorityPDA(jobId: string): [PublicKey, number] {
    return PublicKey.findProgramAddressSync(
      [Buffer.from("escrow"), Buffer.from(jobId)],
      program.programId
    );
  }

  function findEscrowTokenPDA(jobId: string): [PublicKey, number] {
    return PublicKey.findProgramAddressSync(
      [Buffer.from("escrow_token"), Buffer.from(jobId)],
      program.programId
    );
  }

  // ── Setup ─────────────────────────────────────────────────────────────
  before(async () => {
    // Airdrop SOL to all test accounts
    const airdropAccounts = [admin, requester, agent, unauthorizedUser, arbitrator];
    for (const account of airdropAccounts) {
      const sig = await provider.connection.requestAirdrop(
        account.publicKey,
        10 * anchor.web3.LAMPORTS_PER_SOL
      );
      await provider.connection.confirmTransaction(sig);
    }

    // Create token mint
    mint = await createMint(
      provider.connection,
      admin,
      admin.publicKey,
      null,
      6 // 6 decimals
    );

    // Create token accounts
    requesterToken = await createAccount(
      provider.connection,
      requester,
      mint,
      requester.publicKey
    );
    agentToken = await createAccount(
      provider.connection,
      agent,
      mint,
      agent.publicKey
    );

    // Mint tokens to requester
    await mintTo(
      provider.connection,
      admin,
      mint,
      requesterToken,
      admin,
      100_000_000 // 100 tokens
    );
  });

  // ====================================================================
  // 1. INITIALIZATION TESTS
  // ====================================================================

  describe("Initialize", () => {
    it("initializes program config with admin and arbitrator", async () => {
      const [configPDA] = findConfigPDA();

      await program.methods
        .initialize(arbitrator.publicKey)
        .accounts({
          config: configPDA,
          admin: admin.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([admin])
        .rpc();

      const config = await program.account.programConfig.fetch(configPDA);
      assert.ok(config.admin.equals(admin.publicKey));
      assert.ok(config.arbitrator.equals(arbitrator.publicKey));
    });

    it("fails to initialize twice", async () => {
      const [configPDA] = findConfigPDA();

      try {
        await program.methods
          .initialize(arbitrator.publicKey)
          .accounts({
            config: configPDA,
            admin: admin.publicKey,
            systemProgram: SystemProgram.programId,
          })
          .signers([admin])
          .rpc();
        assert.fail("Should have failed");
      } catch (err) {
        // Account already initialized — expected
      }
    });
  });

  // ====================================================================
  // 2. UPDATE CONFIG TESTS
  // ====================================================================

  describe("UpdateConfig", () => {
    it("admin can update arbitrator", async () => {
      const [configPDA] = findConfigPDA();
      const newArbitrator = Keypair.generate();

      await program.methods
        .updateConfig(newArbitrator.publicKey, null)
        .accounts({
          config: configPDA,
          admin: admin.publicKey,
        })
        .signers([admin])
        .rpc();

      const config = await program.account.programConfig.fetch(configPDA);
      assert.ok(config.arbitrator.equals(newArbitrator.publicKey));

      // Restore original arbitrator for remaining tests
      await program.methods
        .updateConfig(arbitrator.publicKey, null)
        .accounts({
          config: configPDA,
          admin: admin.publicKey,
        })
        .signers([admin])
        .rpc();
    });

    it("non-admin cannot update config", async () => {
      const [configPDA] = findConfigPDA();

      try {
        await program.methods
          .updateConfig(unauthorizedUser.publicKey, null)
          .accounts({
            config: configPDA,
            admin: unauthorizedUser.publicKey,
          })
          .signers([unauthorizedUser])
          .rpc();
        assert.fail("Should have failed");
      } catch (err) {
        expect(err.toString()).to.contain("Unauthorized");
      }
    });
  });

  // ====================================================================
  // 3. CREATE JOB TESTS
  // ====================================================================

  describe("CreateJob", () => {
    it("creates a job with funds escrowed", async () => {
      const [jobPDA] = findJobPDA(JOB_ID);
      const [escrowAuthority] = findEscrowAuthorityPDA(JOB_ID);
      const [escrowToken] = findEscrowTokenPDA(JOB_ID);

      const balanceBefore = (await getAccount(provider.connection, requesterToken)).amount;

      await program.methods
        .createJob(JOB_ID, new anchor.BN(JOB_AMOUNT), JOB_DESCRIPTION, DEADLINE_DAYS)
        .accounts({
          job: jobPDA,
          escrowAuthority: escrowAuthority,
          escrowToken: escrowToken,
          requester: requester.publicKey,
          requesterToken: requesterToken,
          mint: mint,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
          rent: SYSVAR_RENT_PUBKEY,
        })
        .signers([requester])
        .rpc();

      // Verify job state
      const job = await program.account.job.fetch(jobPDA);
      assert.equal(job.jobId, JOB_ID);
      assert.ok(job.requester.equals(requester.publicKey));
      assert.ok(job.agent.equals(PublicKey.default));
      assert.equal(job.amount.toNumber(), JOB_AMOUNT);
      assert.equal(job.description, JOB_DESCRIPTION);
      assert.deepEqual(job.status, { open: {} });
      assert.ok(job.mint.equals(mint));

      // Verify escrow received funds
      const escrowBalance = (await getAccount(provider.connection, escrowToken)).amount;
      assert.equal(Number(escrowBalance), JOB_AMOUNT);

      // Verify requester balance decreased
      const balanceAfter = (await getAccount(provider.connection, requesterToken)).amount;
      assert.equal(Number(balanceBefore) - Number(balanceAfter), JOB_AMOUNT);
    });

    it("fails with zero amount", async () => {
      const jobId = "zero-amount-job";
      const [jobPDA] = findJobPDA(jobId);
      const [escrowAuthority] = findEscrowAuthorityPDA(jobId);
      const [escrowToken] = findEscrowTokenPDA(jobId);

      try {
        await program.methods
          .createJob(jobId, new anchor.BN(0), "Test", 7)
          .accounts({
            job: jobPDA,
            escrowAuthority: escrowAuthority,
            escrowToken: escrowToken,
            requester: requester.publicKey,
            requesterToken: requesterToken,
            mint: mint,
            tokenProgram: TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
            rent: SYSVAR_RENT_PUBKEY,
          })
          .signers([requester])
          .rpc();
        assert.fail("Should have failed");
      } catch (err) {
        expect(err.toString()).to.contain("ZeroAmount");
      }
    });

    it("fails with job ID too long", async () => {
      const longJobId = "a".repeat(37);
      const [jobPDA] = findJobPDA(longJobId);
      const [escrowAuthority] = findEscrowAuthorityPDA(longJobId);
      const [escrowToken] = findEscrowTokenPDA(longJobId);

      try {
        await program.methods
          .createJob(longJobId, new anchor.BN(1000), "Test", 7)
          .accounts({
            job: jobPDA,
            escrowAuthority: escrowAuthority,
            escrowToken: escrowToken,
            requester: requester.publicKey,
            requesterToken: requesterToken,
            mint: mint,
            tokenProgram: TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
            rent: SYSVAR_RENT_PUBKEY,
          })
          .signers([requester])
          .rpc();
        assert.fail("Should have failed");
      } catch (err) {
        expect(err.toString()).to.contain("JobIdTooLong");
      }
    });
  });

  // ====================================================================
  // 4. ACCEPT JOB TESTS
  // ====================================================================

  describe("AcceptJob", () => {
    it("agent accepts open job", async () => {
      const [jobPDA] = findJobPDA(JOB_ID);

      await program.methods
        .acceptJob()
        .accounts({
          job: jobPDA,
          agent: agent.publicKey,
        })
        .signers([agent])
        .rpc();

      const job = await program.account.job.fetch(jobPDA);
      assert.ok(job.agent.equals(agent.publicKey));
      assert.deepEqual(job.status, { inProgress: {} });
    });

    it("fails to accept already-taken job", async () => {
      const [jobPDA] = findJobPDA(JOB_ID);

      try {
        await program.methods
          .acceptJob()
          .accounts({
            job: jobPDA,
            agent: unauthorizedUser.publicKey,
          })
          .signers([unauthorizedUser])
          .rpc();
        assert.fail("Should have failed");
      } catch (err) {
        // Should fail — job already in progress
      }
    });
  });

  // ====================================================================
  // 5. SUBMIT DELIVERABLE TESTS
  // ====================================================================

  describe("SubmitDeliverable", () => {
    it("assigned agent submits deliverable", async () => {
      const [jobPDA] = findJobPDA(JOB_ID);

      await program.methods
        .submitDeliverable("https://github.com/agent/work", "Completed with tests")
        .accounts({
          job: jobPDA,
          agent: agent.publicKey,
        })
        .signers([agent])
        .rpc();

      const job = await program.account.job.fetch(jobPDA);
      assert.deepEqual(job.status, { underReview: {} });
      assert.ok(job.deliverable.includes("https://github.com/agent/work"));
    });

    it("SECURITY: unauthorized agent cannot submit deliverable", async () => {
      // First create and accept a new job for this test
      const jobId2 = "security-test-submit";
      const [jobPDA2] = findJobPDA(jobId2);
      const [escrowAuth2] = findEscrowAuthorityPDA(jobId2);
      const [escrowToken2] = findEscrowTokenPDA(jobId2);

      await program.methods
        .createJob(jobId2, new anchor.BN(1_000_000), "Security test", 7)
        .accounts({
          job: jobPDA2,
          escrowAuthority: escrowAuth2,
          escrowToken: escrowToken2,
          requester: requester.publicKey,
          requesterToken: requesterToken,
          mint: mint,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
          rent: SYSVAR_RENT_PUBKEY,
        })
        .signers([requester])
        .rpc();

      await program.methods
        .acceptJob()
        .accounts({
          job: jobPDA2,
          agent: agent.publicKey,
        })
        .signers([agent])
        .rpc();

      // Unauthorized user tries to submit
      try {
        await program.methods
          .submitDeliverable("https://evil.com", "Fake work")
          .accounts({
            job: jobPDA2,
            agent: unauthorizedUser.publicKey,
          })
          .signers([unauthorizedUser])
          .rpc();
        assert.fail("Should have failed - unauthorized agent");
      } catch (err) {
        expect(err.toString()).to.contain("Unauthorized");
      }
    });
  });

  // ====================================================================
  // 6. APPROVE AND PAY TESTS (Happy Path)
  // ====================================================================

  describe("ApproveAndPay", () => {
    it("requester approves and pays agent", async () => {
      const [jobPDA] = findJobPDA(JOB_ID);
      const [escrowAuthority] = findEscrowAuthorityPDA(JOB_ID);
      const [escrowToken] = findEscrowTokenPDA(JOB_ID);

      const agentBalanceBefore = (await getAccount(provider.connection, agentToken)).amount;

      await program.methods
        .approveAndPay(5) // 5-star rating
        .accounts({
          job: jobPDA,
          escrowAuthority: escrowAuthority,
          requester: requester.publicKey,
          escrowToken: escrowToken,
          agentToken: agentToken,
          tokenProgram: TOKEN_PROGRAM_ID,
        })
        .signers([requester])
        .rpc();

      const job = await program.account.job.fetch(jobPDA);
      assert.deepEqual(job.status, { completed: {} });
      assert.equal(job.rating, 5);

      // Verify agent received payment
      const agentBalanceAfter = (await getAccount(provider.connection, agentToken)).amount;
      assert.equal(Number(agentBalanceAfter) - Number(agentBalanceBefore), JOB_AMOUNT);
    });

    it("fails with invalid rating", async () => {
      // Need a new job in UnderReview status
      const jobId = "rating-test";
      const [jobPDA] = findJobPDA(jobId);
      const [escrowAuth] = findEscrowAuthorityPDA(jobId);
      const [escrowToken] = findEscrowTokenPDA(jobId);

      await program.methods
        .createJob(jobId, new anchor.BN(1_000_000), "Rating test", 7)
        .accounts({
          job: jobPDA,
          escrowAuthority: escrowAuth,
          escrowToken: escrowToken,
          requester: requester.publicKey,
          requesterToken: requesterToken,
          mint: mint,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
          rent: SYSVAR_RENT_PUBKEY,
        })
        .signers([requester])
        .rpc();

      await program.methods
        .acceptJob()
        .accounts({ job: jobPDA, agent: agent.publicKey })
        .signers([agent])
        .rpc();

      await program.methods
        .submitDeliverable("https://work.com", "Done")
        .accounts({ job: jobPDA, agent: agent.publicKey })
        .signers([agent])
        .rpc();

      try {
        await program.methods
          .approveAndPay(6) // Invalid: > 5
          .accounts({
            job: jobPDA,
            escrowAuthority: escrowAuth,
            requester: requester.publicKey,
            escrowToken: escrowToken,
            agentToken: agentToken,
            tokenProgram: TOKEN_PROGRAM_ID,
          })
          .signers([requester])
          .rpc();
        assert.fail("Should have failed");
      } catch (err) {
        expect(err.toString()).to.contain("InvalidRating");
      }
    });

    it("SECURITY: non-requester cannot approve", async () => {
      const jobId = "rating-test"; // Reuse the job in UnderReview
      const [jobPDA] = findJobPDA(jobId);
      const [escrowAuth] = findEscrowAuthorityPDA(jobId);
      const [escrowToken] = findEscrowTokenPDA(jobId);

      try {
        await program.methods
          .approveAndPay(5)
          .accounts({
            job: jobPDA,
            escrowAuthority: escrowAuth,
            requester: unauthorizedUser.publicKey,
            escrowToken: escrowToken,
            agentToken: agentToken,
            tokenProgram: TOKEN_PROGRAM_ID,
          })
          .signers([unauthorizedUser])
          .rpc();
        assert.fail("Should have failed - unauthorized requester");
      } catch (err) {
        expect(err.toString()).to.contain("Unauthorized");
      }
    });
  });

  // ====================================================================
  // 7. CANCEL JOB TESTS
  // ====================================================================

  describe("CancelJob", () => {
    it("requester cancels open job and gets refund", async () => {
      const jobId = "cancel-test";
      const [jobPDA] = findJobPDA(jobId);
      const [escrowAuth] = findEscrowAuthorityPDA(jobId);
      const [escrowToken] = findEscrowTokenPDA(jobId);

      const amount = 5_000_000;

      await program.methods
        .createJob(jobId, new anchor.BN(amount), "Cancel test", 7)
        .accounts({
          job: jobPDA,
          escrowAuthority: escrowAuth,
          escrowToken: escrowToken,
          requester: requester.publicKey,
          requesterToken: requesterToken,
          mint: mint,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
          rent: SYSVAR_RENT_PUBKEY,
        })
        .signers([requester])
        .rpc();

      const balanceBefore = (await getAccount(provider.connection, requesterToken)).amount;

      await program.methods
        .cancelJob()
        .accounts({
          job: jobPDA,
          escrowAuthority: escrowAuth,
          requester: requester.publicKey,
          escrowToken: escrowToken,
          requesterToken: requesterToken,
          tokenProgram: TOKEN_PROGRAM_ID,
        })
        .signers([requester])
        .rpc();

      const job = await program.account.job.fetch(jobPDA);
      assert.deepEqual(job.status, { cancelled: {} });

      // Verify refund
      const balanceAfter = (await getAccount(provider.connection, requesterToken)).amount;
      assert.equal(Number(balanceAfter) - Number(balanceBefore), amount);
    });

    it("non-requester cannot cancel", async () => {
      const jobId = "cancel-auth-test";
      const [jobPDA] = findJobPDA(jobId);
      const [escrowAuth] = findEscrowAuthorityPDA(jobId);
      const [escrowToken] = findEscrowTokenPDA(jobId);

      await program.methods
        .createJob(jobId, new anchor.BN(1_000_000), "Auth test", 7)
        .accounts({
          job: jobPDA,
          escrowAuthority: escrowAuth,
          escrowToken: escrowToken,
          requester: requester.publicKey,
          requesterToken: requesterToken,
          mint: mint,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
          rent: SYSVAR_RENT_PUBKEY,
        })
        .signers([requester])
        .rpc();

      // Create a token account for the unauthorized user
      const unauthorizedToken = await createAccount(
        provider.connection,
        unauthorizedUser,
        mint,
        unauthorizedUser.publicKey
      );

      try {
        await program.methods
          .cancelJob()
          .accounts({
            job: jobPDA,
            escrowAuthority: escrowAuth,
            requester: unauthorizedUser.publicKey,
            escrowToken: escrowToken,
            requesterToken: unauthorizedToken,
            tokenProgram: TOKEN_PROGRAM_ID,
          })
          .signers([unauthorizedUser])
          .rpc();
        assert.fail("Should have failed");
      } catch (err) {
        expect(err.toString()).to.contain("Unauthorized");
      }
    });
  });

  // ====================================================================
  // 8. DISPUTE RESOLUTION TESTS
  // ====================================================================

  describe("Dispute Resolution", () => {
    const disputeJobId = "dispute-test";

    before(async () => {
      // Create a job and get it to Disputed status
      const [jobPDA] = findJobPDA(disputeJobId);
      const [escrowAuth] = findEscrowAuthorityPDA(disputeJobId);
      const [escrowToken] = findEscrowTokenPDA(disputeJobId);

      await program.methods
        .createJob(disputeJobId, new anchor.BN(10_000_000), "Dispute test", 7)
        .accounts({
          job: jobPDA,
          escrowAuthority: escrowAuth,
          escrowToken: escrowToken,
          requester: requester.publicKey,
          requesterToken: requesterToken,
          mint: mint,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
          rent: SYSVAR_RENT_PUBKEY,
        })
        .signers([requester])
        .rpc();

      await program.methods
        .acceptJob()
        .accounts({ job: jobPDA, agent: agent.publicKey })
        .signers([agent])
        .rpc();

      await program.methods
        .submitDeliverable("https://work.com/result", "Work done")
        .accounts({ job: jobPDA, agent: agent.publicKey })
        .signers([agent])
        .rpc();

      await program.methods
        .rejectWork("Missing tests and documentation")
        .accounts({ job: jobPDA, requester: requester.publicKey })
        .signers([requester])
        .rpc();
    });

    it("job is in Disputed status after rejection", async () => {
      const [jobPDA] = findJobPDA(disputeJobId);
      const job = await program.account.job.fetch(jobPDA);
      assert.deepEqual(job.status, { disputed: {} });
      assert.ok(job.disputed);
    });

    it("SECURITY: unauthorized user CANNOT resolve dispute", async () => {
      const [jobPDA] = findJobPDA(disputeJobId);
      const [configPDA] = findConfigPDA();
      const [escrowAuth] = findEscrowAuthorityPDA(disputeJobId);
      const [escrowToken] = findEscrowTokenPDA(disputeJobId);

      try {
        await program.methods
          .resolveDispute(100) // Try to send 100% to "agent" (which could be attacker's account)
          .accounts({
            job: jobPDA,
            config: configPDA,
            escrowAuthority: escrowAuth,
            arbitrator: unauthorizedUser.publicKey, // NOT the authorized arbitrator
            escrowToken: escrowToken,
            agentToken: agentToken,
            requesterToken: requesterToken,
            tokenProgram: TOKEN_PROGRAM_ID,
          })
          .signers([unauthorizedUser])
          .rpc();
        assert.fail("CRITICAL: Unauthorized user was able to resolve dispute!");
      } catch (err) {
        expect(err.toString()).to.contain("UnauthorizedArbitrator");
      }
    });

    it("authorized arbitrator resolves dispute with split", async () => {
      const [jobPDA] = findJobPDA(disputeJobId);
      const [configPDA] = findConfigPDA();
      const [escrowAuth] = findEscrowAuthorityPDA(disputeJobId);
      const [escrowToken] = findEscrowTokenPDA(disputeJobId);

      const agentBalanceBefore = (await getAccount(provider.connection, agentToken)).amount;
      const requesterBalanceBefore = (await getAccount(provider.connection, requesterToken)).amount;

      const agentPercentage = 60; // 60% to agent, 40% to requester
      const expectedAgentAmount = Math.floor(10_000_000 * 60 / 100);
      const expectedRequesterAmount = 10_000_000 - expectedAgentAmount;

      await program.methods
        .resolveDispute(agentPercentage)
        .accounts({
          job: jobPDA,
          config: configPDA,
          escrowAuthority: escrowAuth,
          arbitrator: arbitrator.publicKey,
          escrowToken: escrowToken,
          agentToken: agentToken,
          requesterToken: requesterToken,
          tokenProgram: TOKEN_PROGRAM_ID,
        })
        .signers([arbitrator])
        .rpc();

      const job = await program.account.job.fetch(jobPDA);
      assert.deepEqual(job.status, { resolved: {} });
      assert.ok(!job.disputed);

      // Verify correct split
      const agentBalanceAfter = (await getAccount(provider.connection, agentToken)).amount;
      const requesterBalanceAfter = (await getAccount(provider.connection, requesterToken)).amount;

      assert.equal(
        Number(agentBalanceAfter) - Number(agentBalanceBefore),
        expectedAgentAmount,
        "Agent should receive 60%"
      );
      assert.equal(
        Number(requesterBalanceAfter) - Number(requesterBalanceBefore),
        expectedRequesterAmount,
        "Requester should receive 40%"
      );
    });

    it("cannot resolve non-disputed job", async () => {
      // Use the completed job from earlier tests
      const [jobPDA] = findJobPDA(JOB_ID);
      const [configPDA] = findConfigPDA();
      const [escrowAuth] = findEscrowAuthorityPDA(JOB_ID);
      const [escrowToken] = findEscrowTokenPDA(JOB_ID);

      try {
        await program.methods
          .resolveDispute(50)
          .accounts({
            job: jobPDA,
            config: configPDA,
            escrowAuthority: escrowAuth,
            arbitrator: arbitrator.publicKey,
            escrowToken: escrowToken,
            agentToken: agentToken,
            requesterToken: requesterToken,
            tokenProgram: TOKEN_PROGRAM_ID,
          })
          .signers([arbitrator])
          .rpc();
        assert.fail("Should have failed");
      } catch (err) {
        expect(err.toString()).to.contain("NotDisputed");
      }
    });
  });

  // ====================================================================
  // 9. SECURITY-SPECIFIC TESTS
  // ====================================================================

  describe("Security Tests", () => {
    it("SECURITY: token account with wrong owner is rejected on approve", async () => {
      // Create a token account owned by the attacker, not the agent
      const attackerToken = await createAccount(
        provider.connection,
        unauthorizedUser,
        mint,
        unauthorizedUser.publicKey
      );

      const jobId = "rating-test"; // Job in UnderReview from earlier
      const [jobPDA] = findJobPDA(jobId);
      const [escrowAuth] = findEscrowAuthorityPDA(jobId);
      const [escrowToken] = findEscrowTokenPDA(jobId);

      try {
        await program.methods
          .approveAndPay(5)
          .accounts({
            job: jobPDA,
            escrowAuthority: escrowAuth,
            requester: requester.publicKey,
            escrowToken: escrowToken,
            agentToken: attackerToken, // Wrong owner!
            tokenProgram: TOKEN_PROGRAM_ID,
          })
          .signers([requester])
          .rpc();
        assert.fail("CRITICAL: Funds sent to wrong token account!");
      } catch (err) {
        expect(err.toString()).to.contain("InvalidTokenOwner");
      }
    });

    it("SECURITY: cannot pass wrong escrow token account", async () => {
      // Try to use a different token account as escrow
      const fakeEscrow = await createAccount(
        provider.connection,
        unauthorizedUser,
        mint,
        unauthorizedUser.publicKey
      );

      const jobId = "rating-test";
      const [jobPDA] = findJobPDA(jobId);
      const [escrowAuth] = findEscrowAuthorityPDA(jobId);

      try {
        await program.methods
          .approveAndPay(5)
          .accounts({
            job: jobPDA,
            escrowAuthority: escrowAuth,
            requester: requester.publicKey,
            escrowToken: fakeEscrow, // Wrong escrow!
            agentToken: agentToken,
            tokenProgram: TOKEN_PROGRAM_ID,
          })
          .signers([requester])
          .rpc();
        assert.fail("CRITICAL: Used wrong escrow token account!");
      } catch (err) {
        // Should fail due to PDA seed mismatch
      }
    });

    it("SECURITY: reject_work fails for non-requester", async () => {
      const jobId = "security-test-submit"; // Job in InProgress
      const [jobPDA] = findJobPDA(jobId);

      // First submit deliverable so job is UnderReview
      await program.methods
        .submitDeliverable("https://work.com", "Work")
        .accounts({ job: jobPDA, agent: agent.publicKey })
        .signers([agent])
        .rpc();

      try {
        await program.methods
          .rejectWork("Fake rejection")
          .accounts({
            job: jobPDA,
            requester: unauthorizedUser.publicKey,
          })
          .signers([unauthorizedUser])
          .rpc();
        assert.fail("Should have failed - unauthorized rejection");
      } catch (err) {
        expect(err.toString()).to.contain("Unauthorized");
      }
    });
  });

  // ====================================================================
  // 10. EDGE CASE TESTS
  // ====================================================================

  describe("Edge Cases", () => {
    it("dispute resolution with 0% to agent (full refund)", async () => {
      const jobId = "full-refund-test";
      const [jobPDA] = findJobPDA(jobId);
      const [escrowAuth] = findEscrowAuthorityPDA(jobId);
      const [escrowToken] = findEscrowTokenPDA(jobId);
      const [configPDA] = findConfigPDA();

      const amount = 5_000_000;

      await program.methods
        .createJob(jobId, new anchor.BN(amount), "Refund test", 7)
        .accounts({
          job: jobPDA,
          escrowAuthority: escrowAuth,
          escrowToken: escrowToken,
          requester: requester.publicKey,
          requesterToken: requesterToken,
          mint: mint,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
          rent: SYSVAR_RENT_PUBKEY,
        })
        .signers([requester])
        .rpc();

      await program.methods.acceptJob()
        .accounts({ job: jobPDA, agent: agent.publicKey })
        .signers([agent]).rpc();

      await program.methods.submitDeliverable("https://x.com", "Work")
        .accounts({ job: jobPDA, agent: agent.publicKey })
        .signers([agent]).rpc();

      await program.methods.rejectWork("Terrible")
        .accounts({ job: jobPDA, requester: requester.publicKey })
        .signers([requester]).rpc();

      const requesterBefore = (await getAccount(provider.connection, requesterToken)).amount;

      await program.methods
        .resolveDispute(0) // 0% to agent = full refund
        .accounts({
          job: jobPDA,
          config: configPDA,
          escrowAuthority: escrowAuth,
          arbitrator: arbitrator.publicKey,
          escrowToken: escrowToken,
          agentToken: agentToken,
          requesterToken: requesterToken,
          tokenProgram: TOKEN_PROGRAM_ID,
        })
        .signers([arbitrator])
        .rpc();

      const requesterAfter = (await getAccount(provider.connection, requesterToken)).amount;
      assert.equal(Number(requesterAfter) - Number(requesterBefore), amount);
    });

    it("dispute resolution with 100% to agent", async () => {
      const jobId = "full-agent-test";
      const [jobPDA] = findJobPDA(jobId);
      const [escrowAuth] = findEscrowAuthorityPDA(jobId);
      const [escrowToken] = findEscrowTokenPDA(jobId);
      const [configPDA] = findConfigPDA();

      const amount = 5_000_000;

      await program.methods
        .createJob(jobId, new anchor.BN(amount), "Agent test", 7)
        .accounts({
          job: jobPDA,
          escrowAuthority: escrowAuth,
          escrowToken: escrowToken,
          requester: requester.publicKey,
          requesterToken: requesterToken,
          mint: mint,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
          rent: SYSVAR_RENT_PUBKEY,
        })
        .signers([requester])
        .rpc();

      await program.methods.acceptJob()
        .accounts({ job: jobPDA, agent: agent.publicKey })
        .signers([agent]).rpc();

      await program.methods.submitDeliverable("https://x.com", "Work")
        .accounts({ job: jobPDA, agent: agent.publicKey })
        .signers([agent]).rpc();

      await program.methods.rejectWork("Disagree")
        .accounts({ job: jobPDA, requester: requester.publicKey })
        .signers([requester]).rpc();

      const agentBefore = (await getAccount(provider.connection, agentToken)).amount;

      await program.methods
        .resolveDispute(100) // 100% to agent
        .accounts({
          job: jobPDA,
          config: configPDA,
          escrowAuthority: escrowAuth,
          arbitrator: arbitrator.publicKey,
          escrowToken: escrowToken,
          agentToken: agentToken,
          requesterToken: requesterToken,
          tokenProgram: TOKEN_PROGRAM_ID,
        })
        .signers([arbitrator])
        .rpc();

      const agentAfter = (await getAccount(provider.connection, agentToken)).amount;
      assert.equal(Number(agentAfter) - Number(agentBefore), amount);
    });

    it("fails to resolve with percentage > 100", async () => {
      const jobId = "pct-overflow-test";
      const [jobPDA] = findJobPDA(jobId);
      const [escrowAuth] = findEscrowAuthorityPDA(jobId);
      const [escrowToken] = findEscrowTokenPDA(jobId);
      const [configPDA] = findConfigPDA();

      await program.methods
        .createJob(jobId, new anchor.BN(1_000_000), "Overflow test", 7)
        .accounts({
          job: jobPDA,
          escrowAuthority: escrowAuth,
          escrowToken: escrowToken,
          requester: requester.publicKey,
          requesterToken: requesterToken,
          mint: mint,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
          rent: SYSVAR_RENT_PUBKEY,
        })
        .signers([requester])
        .rpc();

      await program.methods.acceptJob()
        .accounts({ job: jobPDA, agent: agent.publicKey })
        .signers([agent]).rpc();

      await program.methods.submitDeliverable("https://x.com", "Work")
        .accounts({ job: jobPDA, agent: agent.publicKey })
        .signers([agent]).rpc();

      await program.methods.rejectWork("Bad")
        .accounts({ job: jobPDA, requester: requester.publicKey })
        .signers([requester]).rpc();

      try {
        await program.methods
          .resolveDispute(101) // > 100 is invalid, but u8 max is 255
          .accounts({
            job: jobPDA,
            config: configPDA,
            escrowAuthority: escrowAuth,
            arbitrator: arbitrator.publicKey,
            escrowToken: escrowToken,
            agentToken: agentToken,
            requesterToken: requesterToken,
            tokenProgram: TOKEN_PROGRAM_ID,
          })
          .signers([arbitrator])
          .rpc();
        assert.fail("Should have failed");
      } catch (err) {
        expect(err.toString()).to.contain("InvalidPercentage");
      }
    });
  });
});
